# Use bind for composable error handling with nested Eithers
## Part 2 - Pulling it all together

![series banner](../resources/glitched-abstract.jpg)

> *Note: This is* **Tutorial 4 - Part 2** *in the series* **Make the leap from JavaScript to PureScript** *. Be sure*
> *to read the series introduction where we cover the goals & outline, and the installation,*
> *compilation, & running of PureScript. I will be publishing a new tutorial approximately*
> *once-per-week. So come back often, there is a lot more to come!*

> [<< Introduction](https://github.com/adkelley/javascript-to-purescript) [< Tutorial 4P1](https://github.com/adkelley/javascript-to-purescript/tree/master/tut04P1)

The series outline and javascript code samples were borrowed with permission from the egghead.io course [Professor Frisby Introduces Composable Functional JavaScript](https://egghead.io/courses/professor-frisby-introduces-composable-functional-javascript) by
[Brian Lonsdorf](https://github.com/DrBoolean) - thank you, Brian! A fundamental assumption of each tutorial is that you've watched his video before tackling the equivalent PureScript abstraction featured in this tutorial.  Brian covers the featured concepts extremely well, and I feel it's better that you understand its implementation in the comfort of JavaScript. Let me mention that if you read something that you feel could be explained better, or a code example that needs refactoring, then please let me know via a comment or send me a pull request on [Github](https://github.com/adkelley/javascript-to-purescript/tree/master/tut04P1).

## Introduction

In [Part 1]((https://github.com/adkelley/javascript-to-purescript/tree/master/tut04P1), I covered how to handle side effects in PureScript.  Recall that a function or expression creates a side effect whenever it modifies some state outside its scope, or it has an observable interaction with its calling function or the outside world.  The core concept is that we don't eliminate side effects because we need them to be able to write useful code.  Instead, we aim to represent them in our code in a way that distinguishes them from our pure computations.  The benefit of being explicit about our side effects is that readers or future maintainers of our code will readily understand what side effects we have created and where we generated them.

I focused on a particular class of side effects, called 'native' side effects (NSEs), and these are side effects that are generated by the runtime system.  Console IO, random number generation, and file IO are all examples of NSEs.  You've already learned how to implement console IO and random number generation in PureScript in Part 1.  Now I’ll show you how to perform File IO.  

But this is not all you are going to learn in this tutorial.  My objective is to sync back up with Brian’s [4th tutorial](https://egghead.io/lessons/javascript-composable-error-handling-with-either) by showing how my PureScript implementation of Brian's `chain` function can be used to compose nested `Either`s together.


## Compiler release update
Since I began writing these tutorials there has been a new release of the PureScript compiler.  Consequently the PureScript code samples in the tutorial github repository xx

## JavaScript's Try/Catch Pattern

Let’s start with a popular design pattern for exception handling called try/catch.  At a high level, a try block lets you test a block of code for errors, and the accompanying catch block will handle any errors.  The JavaScript code example below, from Brian's tutorial, reads a configuration file using the readFileSync method from Node.js and returns a port number.  I have prepared the configuration file containing the JSON object, {“port”: 8888}.  This code parses the JSON object and grabs the port number.  Then, assuming all went well, the try block will return the port number.  But if either readFileSync or JSON.parse fails then the `catch` block will return a default port number of 3000.  Finally, I log the result to the console.

```JavaScript
const fs = require('fs')

const getPort = () => {
  try {
    const str = fs.readFileSync('config.json')
    const config = JSON.parse(str)
    return config.port
  } catch(e) {
    return 3000
  }
}

const result = getPort()
console.log(result)
```

As a final point, notice there is no ceremony or heads-up that we have just created three different side-effects - console IO, file IO, and possibly an exception!  You may be entirely comfortable with that, and it is unquestionably not your fault because of the lack of a type system in JavaScript.  However, to help with readability, you could add a comment that you're creating these side effects.  On big projects, when I am coding in JavaScript or Clojure, I will often declare my types in a comment using quasi PureScript or Haskell type declarations. It is my subtle hint to my clients that we should be doing the project in a functional programming language that has a type system. I'll save this rant for another blog post, so moving on.

Our objective is port this computation to PureScript by using bind to compose nested `Either`s. But first things first - I promised to show you how to read a file using the node’s `fs` module. File IO is an NSE, and like console IO and random number generation (covered in Part 1), I’m going to use the Eff Monad to deal with it.  As I mentioned in Part 1, don't worry if you have not encountered monads yet.  I think it is better to learn by showing concrete examples of an abstraction first so that you develop an intuition about how it works.  Then, reinforce your intuition by combing through the literature to find out more about what you just performed.  So, in that spirit, let us move ahead with the code example.

## File IO in PureScript

```haskell
module Main where

import Prelude
import Control.Monad.Eff (Eff)
import Control.Monad.Eff.Console (CONSOLE, log)
import Control.Monad.Eff.Exception (EXCEPTION)
import Node.Encoding (Encoding(..))
import Node.FS (FS)
import Node.FS.Sync (readTextFile)

main :: forall e. Eff (fs :: FS, console :: CONSOLE, exception :: EXCEPTION | e) Unit
main =
  log =<< readTextFile UTF8 "./resources/config.json"
```

Some of this will be familiar to you from Part 1.  But for the sake of review, let's take it from the top.  We have our usual import suspects, but also adding a few new constructs from PureScript's  Node.js modules that support reading the `config.json` file.  You can check those out using [pursuit](https://pursuit.purescript.org).  In PureScript we are always explicit in our type declarations about what side effects we are creating.  In the `main` function, I am using the effect monad `Eff` to wrap the following NSEs:  First, I use the file system `FS` to read a text file.  Then I log the result from `readTextFile` to the `CONSOLE`.  And finally, an `EXCEPTION` will be raised whenever something goes wrong during `readTextFile`.  

Now, I hope you didn't miss that conspicuous bind operator `( =<<)` connecting `readTextFile` to `log`.  Bind is so crucial to understanding how we are going to compose nested `Either`s in the main code example later on.  So listen up!  Recall that we always wrap our NSEs in the `Eff` monad.  So `readTextFile` generates one of two NSEs (FS or EXCEPTION) and wraps it in the `Eff` monad before returning.  Now, what do we do with it?  

We can't just log something to the console when wrapped in the `Eff` monad - first, we need to take it out of the box. Overcoming this hurdle is very similar to the concept I taught in [Tutorial 1](https://github.com/adkelley/javascript-to-purescript/tree/master/tut01).    Recall that I used `map f (Box x)` to take a value `x` out of our `Box` functor so that we could apply the function `f` to `x` and return `x'`.  But after performing that operation, `map` was also responsible putting `x'` back into the `Box`.  This procedure was necessary for preparing the `Box` for the next computation.

The right associative `bind` operator `(=<<)` (actually its `bindFlipped` but stay with me) is very similar because it takes the result from `readTextFile` out of the `Eff` monad and hands it to `log`.  Subsequently `log` writes this result to the console (creating the NSE `CONSOLE`) and puts it back into the `Eff ` monad. I could have reversed the position of the two functions using the left associative `bind` operator `(>>=)` as in
`readTextFile UTF8 "./resources/config.json" >>= log` instead of  `log =<< readTextFile UTF8 "./resources/config.json" `.  It is all up to your preference, but I feel that my original syntax is more readable.

## Final Thoughts

Congratulations!  With the topic of side effects out of the way, you just cleared a major hurdle toward functional programming in PureScript.  It was enough material to warrant a tutorial, and by giving it this level of attention, I hope you will be comfortable in using them in Part 2.  That’s all and stay tuned for Part 2 where we’ll add the file system to our tool chest of effects and wrestle with handling nested Either expressions.  Stay tuned!

## Navigation
[<< Introduction](https://github.com/adkelley/javascript-to-purescript)[< ](https://github.com/adkelley/javascript-to-purescript/tree/master/tut03) Tutorials [ >](https://github.com/adkelley/javascript-to-purescript/tree/master/tut05)

You may find that the README for the next tutorial is under construction. But if you're an eager beaver and would like to look ahead, then most the of code samples from Brian's [videos](https://egghead.io/courses/professor-frisby-introduces-composable-functional-javascript) have been ported to PureScript already. But I may amend them as I write the accompanying tutorial markdown.
